import numpy as np
from ...circuits.base_circuit import *


print("BASE CIRCUIT OVERVIEW".center(linewid, '^'))
print("\n")
print("CHAPTER 1:QUBITS".center(linewid, '^'))
print(f"Welcome to the Base Circuit Overview, this will give you a brief runthrough of the core functionalities of the Base Circuit and its classes")
print(f"First we can initialise a Qubit as such:")
demo_qub_1 = Qubit(state=[1,0], name=f"Demo q0 Qubit")
print(f"We can print the Qubit and can also set the way it prints as. The default is '{demo_qub_1.display_mode}':")
print(f"Printing as default:\n{demo_qub_1}\n")
demo_qub_1.set_display_mode("vector")
print(f"Printing in mode '{demo_qub_1.display_mode}':\n{demo_qub_1}\n")
demo_qub_1.set_display_mode("both")
print(f"Printing in mode '{demo_qub_1.display_mode}':\n{demo_qub_1}\n")
print(f"We can also define the same qubit with the built in class methods like q0 as such:\n{q0}\n")
print(f"Or also as:\n{Qubit.q0(n=2)}\n")
print(f"As you can see this has made a |00> state and also defining qubits in this way gives the name automatically the ket of that state even when combined\n")
print(f"You can also create a qubit by defining the rho values too as such:")
demo_qub_2 = Qubit(rho=[[0.5,0],[0,0.5]])
print(f"This is in fact a mixed Qubit as we can use qub.state_type '{demo_qub_2.state_type}' to check\n")
print(f"Another way to define a mixed Qubit is by providing the states and subsequent weighting of those states:")
demo_qub_3 = Qubit(state=[[1,0],[0,1]], weights=[0.5,0.5])
print(f"Which if we print first can see:\n{demo_qub_3}\n")
print(f"For more information on the Qubit class check out the Qubit Overview example")

print("CHAPTER 2:GATES".center(linewid, '^'))
print(f"Now we can have a look at applying gates to the Qubits:")
print(f"First, same with states, we have a way to manually define the gates or to use the built in ones")
print(f"Rarely defining your eye gate is needed and most of the time you can obtain the gate needed by tensoring or tweaking an existing gate:")
print(f"Here is a Hadamard and Identity Gate:\n{Hadamard % Identity}\n")
print(f"As you can see weuse the '%' symbol as a way to tensor product gates")
print(f"Another exmaple is the phase gate that can be made as such:\n{Gate.P_Gate(np.pi)}\n")
print(f"Using this you can create any phase gate needed such as a T or S gate which are inbuilt as phase gates with their appropriate angles theta")
print(f"Gates in the circuit are not applied by doing:\n{Hadamard @ q0}\n")
print(f"But rather by applying them through the circuit")
print(f"For more information on the Gate class check out the Gate Overview example")

print("CHAPTER 3:CIRCUIT INTRODUCTION".center(linewid, '^'))
print(f"So, before we start, lets go over a little background information on the circuit")
print(f"As of 29/03/2025, there are 3 circuits, the lightweight circuit, this one and the symbolic circuit")
print(f"This circuit is the most fleshed out and versatile of the circuits, allowing for both sparse and dense matrices and pure and mixed states")
print(f"Crucially, this circuit has two different modes:")
print(f"'Circuit' mode, aptly named, this mode is your classic (i appreciate the pun) quantum circuit, where you take a quantum state")
print(f"And apply a series of gates and measurements to it. The quantum state in question can be as large as the program can handle and")
print(f"Is represented by a density matrix")
print(f"'array' mode is the newer of the two and intended mostly for cryptographic protocols. This mode takes an input of many quantum states,")
print(f"Usually of 1 or 2 qubits and applies many operations either to all the states or to just one and can also measure them too.")
print(f"For the 'array' mode, the circuit must be deliberately set to it by either setting the mode to that, or by uploading a QubitArray")
print(f"By uploading an array, it will also automatically switch the modes.")
print(f"First however lets like at the circuit mode:")

print("CHAPTER 4:CIRCUIT MODE".center(linewid, '^'))
print(f"First we have to initalise the circuit which is done as such:")
demo_circuit_1 = Circuit(q=2, b=2)
print(f"This has initialised a circuit with 2 qubits and 2 bits. The qubits are always initalised in the |0> state to simulate real life scenarios")
print(f"Next, say we want to have the first qubit as a |+> state and the second as a |1> state,")
print(f"We can do this:")
demo_circuit_1.apply_gate(Hadamard, 0)
demo_circuit_1.apply_gate(X_Gate, 1)
print(f"To see our results we can either use:")
demo_circuit_1.print_state()
print("\n")
print(f"Or simply print the circuit:")
print(demo_circuit_1)
print("\n")
print(f"This was done by applying single gates to each qubit, however we can also apply a gate like such:")
demo_circuit_1.apply_gate(Hadamard % X_Gate)
print(f"To return the state to its original state:\n{demo_circuit_1}\n")
print(f"Lets quickly make a Bell State:")
demo_circuit_1.apply_gate(Hadamard, 0)
demo_circuit_1.apply_gate(CNot)
print(f"Now lets have a look at measurements, first lets get the probability distribution:")
demo_circuit_1.list_probs()
print(f"Naturally, we can see this will collapse into either two different states, as is natural with a Bell state")
print(f"Now lets measure it:")
demo_circuit_1.measure_state()
print(f"This has collapsed both qubits down into the |00> state")
demo_circuit_2 = Circuit(q=2)
print(f"Lets now quickly look at measuring individual qubits instead")
demo_circuit_2.apply_gate(Hadamard % Hadamard)
demo_circuit_2.measure_state(0)
demo_circuit_2.print_state()
print(f"As we can see here, it has measured the state (idk what it is when you run it) and collapsed it down")
print(f"This is done by partially tracing out the qubit you want, measuring it and then retensoring it back into the state")